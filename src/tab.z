// ---------------- DEFINITIONS ----------------

//data structure
pub typ tab {
	umax len,
	umax itmSz,
	umax lenMax,
	ref  dat
}






/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TABLES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                              Tables by I.A.

        These tab objects are "fixed-size arrays" or "immutable arrays". Every
    region of the resulting data is not directly accessible by user, even if
    allocated.

        The length of the table is variable in the range of its maximum length
    given at initialization. Then, this actual length will grow dynamically as
    items are being added/removed from the table. However, the data allocation
    in itself stays unchanged.



    LAZYNESS:

        At start, I wanted to make tables LAZY: By default, holding null data (not
    allocated) until something is being set in it (then allocate only when really
    needed).

        However, this lazyness may lead the risk of having the actual data region
    far from the tab instance in heap memory. This distance may cause some memory
    access performance issues because of non-locality. Therefore, I decided to
    operate allocations "once and for all" for these 2 fields, directly at table
    creation.



    PROS & CONS:

    Advantages among other common structures:
        - Local memory usage, all at the same place (optimal locality)
        - Optimal memory storage (minimum metadata usage, direct data packing)
        - Static at runtime (no more, no less allocations)
        - Can be allocated on the stack (which is not the case here anyway)
    Disadvantages among other common structures:
        - Fixed maximum length (given at initialization)
        - Require big allocation blocks => bad memory re-use
        - Waste memory if not all the table is being used at runtime
        - Can only add & remove items at the end of tab (similar to a stack)



    A WORD ON MEMORY MANAGEMENT WITH THIS COMMON STRUCTURE:

        This program adds a bunch of functions to work with tab objects containing
    references of a specified size in heap. Every data is stored in heap and user
    never has visibility over internal allocations & memory blocks.

        Every interaction on a dynamic amount of memory involves copy from an
    existing heap location to another. This way, user loose responsability of the
    data engaged in any of these operations.

    The only calls involving memory changes at user level are new/free() then.



    Contact: https://github.com/iasebsil83

    Let's Code !                                  By I.A..
******************************************************************************************

    LICENSE:

    stark-os/dev/core/tab
    Copyright (C) 2025 Sebastien SILVANO

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library.

    If not, see <https://www.gnu.org/licenses/>.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */






// ---------------- BASICS ----------------

//existence
pub fct tab.init(umax itmSz, umax lenMax) {
	sbj.len    = 0
	sbj.itmSz  = itmSz
	sbj.lenMax = lenMax

	//no lazy alloc
	if itmSz != 0 { sbj.dat = ^Heap.new(itmSz * lenMax) }
}
pub fct tab.free() {
	^Heap.free(sbj.dat)
}



//unsafe indexing
#CFG  TAB__UNSAFE_ACCESS_ALLOWED { pub \}
#!CFG TAB__UNSAFE_ACCESS_ALLOWED { prv \}
fct tab.unsafe_get(umax idx, ref dst, umax offset){
	#CFG  TAB__HEAP_SAFE { ^Heap.safe_w(  sbj.dat, dst, idx*sbj.itmSz, sbj.itmSz) }
	#!CFG TAB__HEAP_SAFE { ^Heap.unsafe_w(sbj.dat, dst, idx*sbj.itmSz, sbj.itmSz) }
}

#CFG  TAB__UNSAFE_ACCESS_ALLOWED { pub \}
#!CFG TAB__UNSAFE_ACCESS_ALLOWED { prv \}
fct tab.unsafe_set(umax idx, ref src, umax offset){
	#CFG  TAB__HEAP_SAFE { ^Heap.safe_w(  src, sbj.dat, idx*sbj.itmSz, sbj.itmSz) }
	#!CFG TAB__HEAP_SAFE { ^Heap.unsafe_w(src, sbj.dat, idx*sbj.itmSz, sbj.itmSz) }
}



//safe indexing
pub fct tab.safe_get(umax idx, ref dst, umax offset){
	if idx >= sbj.len { #{lle_oob} ret }
	#{lle_scc}
	sbj.unsafe_get(idx, dst, offset)
}
pub fct tab.safe_set(umax idx, ref src, umax offset){
	if(idx >= sbj.len){ #{lle_oob} ret }
	#{lle_scc}
	sbj.unsafe_set(idx, src, offset)
}



//last
pub fct tab.isEmpty() boo {
	ret sbj.len == 0
}
pub fct tab.last(ref dst, umax offset) {
	sbj.safe_get(sbj.len-1, dst, offset)
}
pub fct tab.rmLast() {
	sbj.len -= 1
}
pub fct tab.popLast(ref dst, umax offset) {
	sbj.last(dst, offset)
	sbj.rmLast()
}



//push
#CFG  TAB__UNSAFE_ACCESS_ALLOWED { pub \}
#!CFG TAB__UNSAFE_ACCESS_ALLOWED { prv \}
fct tab.unsafe_push(ref src, umax offset) {
	sbj.unsafe_set(sbj.len, src, offset)
	sbj.len += 1
}

pub fct tab.safe_push(ref src, umax offset) {
	if sbj.len >= sbj.lenMax { #{lle_oob} ret }
	#{lle_scc}
	sbj.unsafe_push(src, offset)
}



//actions as a whole
pub fct tab.empty() {
	sbj.len = 0
}
pub fct tab.overwrite(ref src, umax offset) {
	for i in sbj { sbj.unsafe_set(i, src, offset) }
}
pub fct tab.fullfill(ref src, umax offset) {
	sbj.len = sbj.lenMax
	sbj.overwrite(src)
}



//actions between tabs
pub fct tab.copy(tab src, tab dst) {
	if src.itmSz != dst.itmSz  { #{lle_fai} ret }
	if src.len   >  dst.lenMax { #{lle_oob} ret }
	#{lle_scc}

	//don't care about what was in dst, just write in it
	dst.len = 0 //<=> dst.empty()
	ref itm = ^Heap.new(src.itmSz)
	for i in src {
		src.unsafe_get(i, itm, 0)
		dst.unsafe_push(itm, 0)
	}
	^Heap.free(itm)
}
